# -*- encoding : utf-8 -*-
# Copyright:: Copyright (c) 2011 Rosetta Stone
# License:: All rights reserved.
require 'rosetta_stone/encryption/blowfish'
require 'rosetta_stone/encryption/token_verification'

# This is like "Token Verification Lite".  The blowfish tokens are much shorter than ones generated by the default TokenVerification implementation.
# This class uses Blowfish symmetric encryption (using the public key) with a 16-byte RSA signature (using the private key).
module RosettaStone
  module Encryption
    module BlowfishTokenVerification

      def self.included(target_class)
        target_class.send(:include, RosettaStone::Encryption::TokenVerification)
        target_class.extend(ClassMethods)
      end

      module ClassMethods

        def encrypt_data(message)
          RosettaStone::Encryption::Blowfish.encrypt(message, RosettaStone::Encryption::Helper.sha256(public_key))
        end

        def sign(encrypted_data)
          RosettaStone::Encryption::Rsa.sign(RosettaStone::Encryption::Helper.sha256(encrypted_data), private_key)[0...signature_length]
        end

      private

        def decrypt_data(encrypted_data)
          RosettaStone::Encryption::Blowfish.decrypt(encrypted_data, RosettaStone::Encryption::Helper.sha256(public_key))
        end

        # since we don't want to transmit the entire 256-byte RSA signature, we can't use unsign here.  instead, we're re-signing the
        # data and comparing the first N bytes of the signatures.  i don't know enough about encryption to understand how much
        # security we're giving up here.  still seems pretty damn hard to fake if you don't have our keys...
        def verify_signature(signature, encrypted_data)
          signature == sign(encrypted_data)
        end

        def signature_length
          16 # bytes
        end
      end
    end
  end
end
